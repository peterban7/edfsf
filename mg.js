const http = require('http');
const express = require('express');
const app = express();
app.get("/", (request, response) => {
  response.sendStatus(200);
});
app.listen(process.env.PORT);
setInterval(() => {
  http.get(`http://apbot.glitch.me/`);
}, 280000);
const { Client, RichEmbed } = require("discord.js");
var { Util } = require('discord.js');
const {YT_API_KEY, prefix, devs} = require('./config')
const client = new Client({ disableEveryone: true})
const ytdl = require("ytdl-core");
const canvas = require("canvas");
const Canvas = require("canvas");
const convert = require("hh-mm-ss")
const botversion = require('./package.json').version;
const moment = require("moment");
const fs = require('fs');
const util = require("util")
const gif = require("gif-search");
const opus = require("node-opus");
const ms = require("ms");
const jimp = require("jimp");
const { get } = require('snekfetch');
const guild = require('guild');
const dateFormat = require('dateformat');//npm i dateformat
const hastebins = require('hastebin-gen');
const pretty = require("pretty-ms");
const cd = require('countdown');
const totime = require('to-time');
const Enmap = require('enmap');
const dbg = new Enmap({ name: 'Giveaway' });
client.login(process.env.MG_TOKEN);
const queue = new Map();
var table = require('table').table
const getYoutubeID = require('get-youtube-id');
const fetchVideoInfo = require('youtube-info');
const YouTube = require('simple-youtube-api');
const youtube = new YouTube("");
client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});
/////[ STATUS ]////
client.on('ready', () => {
 client.user.setStatus("online")
});
client.on('ready', () => {
     client.user.setActivity("$help",{type: 'playing'});
 
});



//help
client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "help") {
    message.channel.send(`                      
<a:600958738127650816:759382983173341215>-| Help Menu.
----------------------------------
<a:8888:759379685875384360>-| $Public â‡ __Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø¹Ø§Ù…Ø©__
<a:9999:759379701432057866>-| $Admin â‡ __Ù‚Ø§Ø¦Ù…Ø© Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø§Ø¯Ù…Ù†__
<a:600958726068895755:759379728833970196>-| $Music â‡ __Ù‚Ø§Ø¦Ù…Ø© Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚ÙŠ__
<a:7777:759379717375393832>-| $Tickets â‡ __Ù‚Ø§Ø¦Ù…Ø© Ø§ÙˆØ§Ù…Ø± Ø§Ù„ØªÙŠÙƒØª__
<a:sr:760123528040808478>-| $Games â‡ __Ù„Ø¹Ø±Ø¶ Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø§Ù„Ø¹Ø§Ø¨__
<a:pl:760157104681779261>-| $Protection â‡ __Ø§ÙˆØ§Ù…Ø± Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§Øª__
<a:Giveaway2:763564249867223040>-| $Giveaway â‡ __Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø¬ÙŠÙ Ø§ÙˆØ§ÙŠ__
----------------------------------
   `);
  }
});






client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "Public") {
    message.channel.send(`
-| General commands.
----------------------------------
<a:0009:759382993445060640>-| **$ping** â‡ __Ù„Ù…Ø¹Ø±ÙØ© Ø³Ø±Ø¹Ø© Ø§ØªØµØ§Ù„ Ø§Ù„Ø¨ÙˆØª__
<a:0009:759382993445060640>-| **$gRole <Rolename>** â‡ __ÙŠÙˆØ±ÙŠÙƒ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø±ØªØ¨Ø© Ø¨Ø§Ø³Ù…Ù‡Ø§ Ø§Ùˆ Ø§Ù„Ø§ÙŠØ¯ÙŠ Ø­Ù‚Ù‡Ø§__
<a:0009:759382993445060640>-| **$bot** â‡ __ÙŠØ¹Ø±Ø¶ Ù„Ùƒ ÙƒÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª__
<a:0009:759382993445060640>-| **$say** â‡ __ÙŠÙƒØ±Ø± Ø§Ù„ÙƒÙ„Ø§Ù… Ø§Ù„ÙŠ ØªÙƒØªØ¨Ùˆ__
<a:0009:759382993445060640>-| **$savatar** â‡ __ØµÙˆØ±Ø© Ø§Ù„Ø³ÙŠØ±ÙØ±__
<a:0009:759382993445060640>-| **$id** â‡ __Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù†Ùƒ__
<a:0009:759382993445060640>-| **$avt** â‡ __ØµÙˆØ±ØªÙƒ Ø§Ùˆ ØµÙˆØ±Ø© Ø§Ù„ÙŠ ØªØ­Ø· Ø§Ù„Ø£ÙŠØ¯ÙŠ Ø¨ØªØ§Ø¹Ù‡__
<a:0009:759382993445060640>-| **$inv** â‡ __Ù„Ø£Ø®Ø° Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨ÙˆØª__
<a:0009:759382993445060640>-| Server bot â‡ https://discord.gg/h6yYdV9
----------------------------------
   `);
  }
});




client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "Music") {
    message.channel.send(`
<a:ms:759815116446236672>-| Music commands.
----------------------------------
<a:600958726068895755:759379728833970196>-| **$Play** â‡ __ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§ØºÙ†ÙŠØ© Ø§Ùˆ Ø§Ø¶Ø§ÙØªÙ‡Ø§ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ùˆ Ø§ÙƒÙ…Ø§Ù„ Ø§Ù„Ø§ØºÙ†ÙŠØ© [p]__
<a:600958726068895755:759379728833970196>-| **$Pause** â‡ __Ø§ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª Ø§Ù„Ø§ØºÙ†ÙŠØ©__
<a:600958726068895755:759379728833970196>-| **$Resume** â‡ __Ø§ÙƒÙ…Ø§Ù„ Ø§Ù„Ø§ØºÙ†ÙŠØ©__ 
<a:600958726068895755:759379728833970196>-| **$stop** â‡ __Ù„Ø£ÙŠÙ‚Ø§Ù Ø§Ù„Ø£ØºÙ†ÙŠØ© ÙˆØ®Ø±ÙˆØ¬ Ø§Ù„Ø¨ÙˆØª Ù…Ù† Ø§Ù„Ø±ÙˆÙ…__
<a:600958726068895755:759379728833970196>-| **$forceskip** â‡ __Ù„ØªØ®Ø·ÙŠ Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø¨Ø´ÙƒÙ„ Ù…Ø¨Ø§Ø´Ø±__
<a:600958726068895755:759379728833970196>-| **$Queue** â‡ __Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©__ 
<a:600958726068895755:759379728833970196>-| **$skipto** â‡ __Ù„ØªØ®Ø·ÙŠ Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„Ù‰ Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© ÙÙŠ Ø·Ø§Ø¨ÙˆØ± Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ù‚Ø§Ø¯Ù…Ø©__
<a:600958726068895755:759379728833970196>-| **$Skip** â‡ __ØªØ®Ø·ÙŠ Ù„Ù„Ø§ØºÙ†ÙŠØ© Ø§Ù„ØªØ§Ù„ÙŠØ©__
<a:600958726068895755:759379728833970196>-| **$Volume** â‡ __ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØª [vol]__
<a:600958726068895755:759379728833970196>-| **$repeat** =â‡ __ØªÙƒØ±Ø§Ø± Ø§Ù„Ø§ØºÙ†ÙŠØ©__
----------------------------------
   `);
  }
});



client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "Admin") {
    message.channel.send(`
<a:9999:759379701432057866>-| Admin commands.
----------------------------------
<a:sh:759921991054000148>-| **$schannel** â‡ __Ø§Ø¶Ù‡Ø§Ø± Ø§Ù„Ø´Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ©__
<a:sh:759921991054000148>-| **$hchannel** â‡ __Ø§Ø®ÙØ§Ø¡ Ø§Ù„Ø´Ø§Øª__
<a:sh:759921991054000148>-| **$talk** â‡ __Ù„Ù„ØªÙƒÙ„Ù… Ø¨ØµÙØ© Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø±ÙˆÙ… Ù…Ø¹ÙŠÙ†__
<a:sh:759921991054000148>-| **$server** â‡ __ÙŠØ¹Ø±Ø¶ Ù„Ùƒ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±__
<a:sh:759921991054000148>-| **$sug** â‡ __Ù„ØµÙ†Ø¹ Ø§Ù‚ØªØ±Ø§Ø­ Ù„Ø§Ø²Ù… Ø±ÙˆÙ… Ø§Ø³Ù…Ù‡Ø§ suggestions__
<a:sh:759921991054000148>-| **$allbots** â‡ __ÙŠÙˆØ±ÙŠÙƒ ÙƒÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª ÙÙŠ Ø³ÙŠØ±ÙØ±Ùƒ__
<a:sh:759921991054000148>-| **$Ù…Ø³Ø­** / **$clear** â‡ __Ù„Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª__
<a:sh:759921991054000148>-| **$mute @user <reason>** â‡ __Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¹Ø¶Ùˆ Ù…ÙŠÙˆØª Ù„Ø§Ø²Ù… Ø±ØªØ¨Ø© ÙˆÙƒÙ…Ø§Ù† Ù…ØªÙ†Ø³Ø§Ø´ ØªØ®Ù„ÙŠ Ø§Ù„Ø±ØªØ¨Ø© Ù…ÙŠÙ†ÙØ¹Ø´ ØªØªÙƒÙ„Ù… ÙÙŠ Ø§Ù„Ø´Ø§Øª <Muted>__
<a:sh:759921991054000148>-| **$unmute @user** â‡ __Ù„ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù† Ø§Ù„Ø´Ø®Øµ__ 
<a:sh:759921991054000148>-| **$kick @user <reason>** â‡ __Ø·Ø±Ø¯ Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±__
<a:sh:759921991054000148>-| **$ban @user <reason>** â‡ __Ø­Ø¶Ø± Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±__
<a:sh:759921991054000148>-| **$unban ID** â‡ __Ù„ÙÙƒ Ø­Ø¶Ø± Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±__
<a:sh:759921991054000148>-| **$Ù‚ÙÙ„** / **$close** â‡ __ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øª__
<a:sh:759921991054000148>-| **$ÙØªØ­** / **$open** â‡ __ÙØªØ­ Ø§Ù„Ø´Ø§Øª__
<a:sh:759921991054000148>-| **$warn @user <reason>** â‡ __Ù„ØªØ­Ø°ÙŠØ± Ø§Ø­Ø¯__
<a:sh:759921991054000148>-| **$warnings** â‡ __Ø§Ù„Ø£Ø¸Ù‡Ø§Ø± ÙƒÙ„ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª__
<a:sh:759921991054000148>-| **$removewarn** / **$rmv** â‡ __Ù„Ø£Ø²Ø§Ù„Ø© ØªØ­Ø°ÙŠØ±__
<a:sh:759921991054000148>-| **$setlog** â‡ __Ù„Ø¹Ù…Ù„ Ø±ÙˆÙ… Ø§Ù„Ù„ÙˆÙ‚__
<a:sh:759921991054000148>-| **$setlog** â‡ __Ù„Ø¹Ù…Ù„ Ø±ÙˆÙ… Ø§Ù„Ù„ÙˆÙ‚__
----------------------------------
   `);
  }
});




client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "Tickets") {
    message.channel.send(`
<a:7777:759379717375393832>-| Ticket list.
----------------------------------
<a:ti:760112703259541545>-| **$tic** â‡ __Ù„ÙØªØ­ ØªÙƒØª__
<a:ti:760112703259541545>-| **$Ø§ØºÙ„Ø§Ù‚** / **$Close tic** â‡ __Ù„Ø£ØºÙ„Ø§Ù‚ Ø§Ù„ØªÙƒØª__
----------------------------------
   `);
  }
});




client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "Games") {
    message.channel.send(`
<a:9999:759379701432057866>-| Games commands.
----------------------------------
<a:XO:760486390491643904>-| **$xo** â‡ __game xo__
<a:Hack:760488862795038720>-| **$hack** â‡ __game hack__
<a:kill:760490312404566020>-| **$kill** â‡ __game kill__
----------------------------------
   `);
  }
});




client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "Protection") {
    message.channel.send(`
<a:pl:760157104681779261>-| Protection commands.
----------------------------------
<a:Protection:760157956020109312>-| **$settings limitsban <number>** â‡ __ØªØ­Ø¯Ø¯ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ Ù„Ùˆ Ø­Ø¯ Ø¨Ù†Ø¯  Ø¨ÙŠØ´ØªØ§Ù„ Ø±ØªØ¨ØªÙ‡__
<a:Protection:760157956020109312>-| **$settings limitskick <number>** â‡ __ØªØ­Ø¯Ø¯ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ Ù„Ùˆ Ø­Ø¯ Ø·Ø±Ø¯ 3 Ø§Ùˆ 4 Ø¨ÙŠØ´ØªØ§Ù„ Ø±ØªØ¨ØªÙ‡__
<a:Protection:760157956020109312>-| **$settings limitsroleD <number>** â‡ __ØªØ­Ø¯Ø¯ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ Ù„Ùˆ Ø­Ø¯ Ù…Ø³Ø­ Ø±ÙˆÙ„ 3 Ø§Ùˆ 4 Ø¨ÙŠØ´ØªØ§Ù„ Ø±ØªØ¨ØªÙ‡__
<a:Protection:760157956020109312>-| **$settings limitsroleC <number>** â‡ __ØªØ­Ø¯Ø¯ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ Ù„Ùˆ Ø­Ø¯ ØµÙ†Ø¹ Ø±ÙˆÙ„ 3 Ø§Ùˆ 4 Ø¨ÙŠØ´ØªØ§Ù„ Ø±ØªØ¨ØªÙ‡__
<a:Protection:760157956020109312>-| **$settings limitschannelD <number>** â‡ __ØªØ­Ø¯Ø¯ Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ Ù„Ùˆ Ø­Ø¯ Ù…Ø³Ø­ Ø±ÙˆÙ… 3 Ø§Ùˆ 4 Ø¨ÙŠØ´ØªØ§Ù„ Ø±ØªØ¨ØªÙ‡__
<a:Protection:760157956020109312>-| **$settings limitstime <number>** â‡ __ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø°ÙŠ Ù…Ù† Ø®Ù„Ø§Ù„Ø© ÙŠØªÙ… Ø§Ù„ØªØ¨Ù†ÙŠØ¯ ÙƒÙ€ Ù…Ø«Ø§Ù„ Ø§Ø°Ø§ Ø´Ø®Øµ Ø¨Ù†Ø¯ 5 ÙÙŠ Ø¯Ù‚ÙŠÙ‚Ø© ØªÙ†Ø²Ù„ Ø±ØªØ¨ØªØ©__
<a:Protection:760157956020109312>-| **$antibots on** â‡ __Ù…Ù†Ø¹ Ø¯Ø®ÙˆÙ„ Ø¨ÙˆØªØ§Øª__
<a:Protection:760157956020109312>-| **$antibots off** â‡ __ÙØªØ­ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø¨ÙˆØªØ§Øª__
----------------------------------
   `);
  }
});




client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "Giveaway") {
    message.channel.send(`                      
<a:Giveaway2:763564249867223040>-| Giveaway Menu.
----------------------------------
<a:Giveaway:763564262466519081>-| **$create <time> <winners> <prize>** â‡ __Ø¹Ù…Ù„ Ø¬ÙŠÙ Ø§ÙˆØ§ÙŠ__
<a:Giveaway:763564262466519081>-| **$end + Message Id** â‡ __Ù„Ø§Ù†Ù‡Ø§Ø¡ Ø¬ÙŠÙ Ø§ÙˆØ§ÙŠ Ø¨Ø¯ÙˆÙ† ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØ§Ø¦Ø²__
<a:Giveaway:763564262466519081>-| **$reroll + Message Id** â‡ __Ù„Ø§Ø®ØªÙŠØ§Ø± Ø´Ø®Øµ Ø§Ø®Ø± Ù„Ù„ÙÙˆØ² Ø¨ Ø§Ù„Ø¬ÙŠÙ Ø§ÙˆØ§ÙŠ__
----------------------------------
   `);
  }
});





////ping
client.on('message' , message => {
  if(message.author.bot) return;
  if(message.content == prefix + "ping") {
 message.channel.send('â€º pong | :ping_pong: ').then((msg) => {
var PinG = `${Date.now() - msg.createdTimestamp}`
var ApL = `${Math.round(client.ping)}`
      msg.edit(`\`\`\`javascript\nâ€º Time taken: ${PinG} ms.\nâ€º Discord API: ${ApL} ms.\`\`\``);
 })
  }  
 });





//moveall
 client.on('message', message => {
    if(message.content.startsWith(prefix + 'moveall')) {
     if (!message.member.hasPermission("MOVE_MEMBERS")) return message.channel.send('**Ù„Ø§ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø³Ø­Ø¨ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡**');
       if(!message.guild.member(client.user).hasPermission("MOVE_MEMBERS")) return message.reply("**Ù„Ø§ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø³Ø­Ø¨**");
    if (message.member.voiceChannel == null) return message.channel.send(`**Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ø±ÙˆÙ… ØµÙˆØªÙŠ**`)
     var author = message.member.voiceChannelID;
     var m = message.guild.members.filter(m=>m.voiceChannel)
     message.guild.members.filter(m=>m.voiceChannel).forEach(m => {
     m.setVoiceChannel(author)
     })
     message.channel.send(`**ØªÙ… Ø³Ø­Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„ÙŠ Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ØµÙˆØªÙŠ Ø­Ù‚Ùƒ.**`)


     }
       });











//Ø§Ø®ØªØµØ§Ø± Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
const shorten = require('isgd');
client.on('message', message => {
 if (message.content.startsWith(prefix + 'short')) {
    let args = message.content.split(" ").slice(1);
  if (!args[0]) return message.channel.send('**Ø§Ø³ØªØ¹Ù…Ù„**: '+ prefix +'short <Ø±Ø§Ø¨Ø·>')
  if (!args[1]) {
    shorten.shorten(args[0], function(res) {
      if (res.startsWith('Error:')) return message.channel.send('**Usage**: '+ prefix +'short <link>');
      message.channel.send(`Ø§Ø®ØªØµØ§Ø± Ø§Ù„Ø±Ø§Ø¨Ø·:**${res}**`);
    })
  } else {
    shorten.custom(args[0], args[1], function(res) {
      if (res.startsWith('Error:')) return message.channel.send(`Ø§Ø®ØªØµØ§Ø± Ø§Ù„Ø±Ø§Ø¨Ø·:**${res}**`);
      message.channel.send(`Ø§Ø®ØªØµØ§Ø± Ø§Ù„Ø±Ø§Ø¨Ø·:**${res}**`);
})
}}
});







//clear
client.on("message", message => {
  if (message.author.bot) return; ///Pixel Team
  if (message.content.startsWith("$clear")) {
    if (!message.channel.guild)
      return message.reply(`** This Command For Servers Only**`);
    if (!message.member.hasPermission("MANAGE_GUILD"))
      return message.channel.send(`** You don't have Premissions!**`);
    if (!message.guild.member(client.user).hasPermission("MANAGE_GUILD"))
      return message.channel.send(`**I don't have Permission!**`);
    let args = message.content.split(" ").slice(1);
    let messagecount = parseInt(args);
    if (args > 100)
      return message
        .reply(`** The number can't be more than **100** .**`)
        .then(messages => messages.delete(5000));
    if (!messagecount) args = "100";
    message.channel
      .fetchMessages({ limit: messagecount })
      .then(messages => message.channel.bulkDelete(messages))
      .then(msgs => {
        message.channel
          .send(`** Done , Deleted \`${msgs.size}\` messages.** `)
          .then(messages => messages.delete(5000));
      });
  }
});



client.on("message", message => {
  if (message.author.bot) return; ///Pixel Team
  if (message.content.startsWith("$Ù…Ø³Ø­")) {
    if (!message.channel.guild)
      return message.reply(`** This Command For Servers Only**`);
    if (!message.member.hasPermission("MANAGE_GUILD"))
      return message.channel.send(`** You don't have Premissions!**`);
    if (!message.guild.member(client.user).hasPermission("MANAGE_GUILD"))
      return message.channel.send(`**I don't have Permission!**`);
    let args = message.content.split(" ").slice(1);
    let messagecount = parseInt(args);
    if (args > 100)
      return message
        .reply(`** The number can't be more than **100** .**`)
        .then(messages => messages.delete(5000));
    if (!messagecount) args = "100";
    message.channel
      .fetchMessages({ limit: messagecount })
      .then(messages => message.channel.bulkDelete(messages))
      .then(msgs => {
        message.channel
          .send(`** Done , Deleted \`${msgs.size}\` messages.** `)
          .then(messages => messages.delete(5000));
      });
  }
});


















// ------------ = [Colors] = ------------ //
 
client.on("message", message => {
      if (!message.guild || message.author.bot) return;
        if (message.content == "$colors" || message.content == "Ø§Ù„ÙˆØ§Ù†") {
          var fsn = require('fs-nextra');
          fs.readdir('./colors', async (err, files) => {
              var f = files[Math.floor(Math.random() * files.length)];
              var {
                  Canvas
              } = require('canvas-constructor');
              var x = 0;
              var y = 0;
              if (message.guild.roles.filter(role => !isNaN(role.name)).size <= 0) return;
              message.guild.roles.filter(role => !isNaN(role.name)).sort((b1, b2) => b1.name - b2.name).forEach(() => {
                  x += 100;
                  if (x > 100 * 12) {
                      x = 100;
                      y += 80;
                  }
              });
              var image = await fsn.readFile(`./colors/${f}`);
              var xd = new Canvas(100 * 11, y + 350)
                  .addBeveledImage(image, 0, 0, 100 * 11, y + 260, 25)
                  .setTextBaseline('middle')
                  .setColor('black')
                  .setTextSize(80)
                  .addText(`Color List`, 375, 75);
              x = 0;
              y = 150;
              message.guild.roles.filter(role => !isNaN(role.name)).sort((b1, b2) => b1.name - b2.name).forEach(role => {
                  x += 75;
                  if (x > 100 * 10) {
                      x = 75;
                      y += 80;
                  }
                  xd
                      .setTextBaseline('middle')
                      .setTextAlign('center')
                      .setColor(role.hexColor)
                      .addBeveledRect(x, y, 60, 60, 15)
                      .setColor('white');
                  if (`${role.name}`.length > 2) {
                      xd.setTextSize(30);
                  } else if (`${role.name}`.length > 1) {
                      xd.setTextSize(40);
                  } else {
                      xd.setTextSize(50);
                  }
                  xd.addText(role.name, x + 30, y + 30);
              });
              message.channel.sendFile(xd.toBuffer());
          });
      }
  })
 



 // ------------ = [select   Colors] = ------------ //
 
client.on('message', message => {
  let args = message.content.split(' ').slice(1);
  if(message.content.split(' ')[0] == prefix+'color' || message.content.split(' ')[0] == 'Ù„ÙˆÙ†'){
  const embedd = new Discord.RichEmbed()
  .setFooter('Requested by '+message.author.username, message.author.avatarURL)
  .setDescription(`<a:x30:714394016883540031> **-** **No Color With This Name/Number **`)
  .setColor(`ff0000`)
 
  if(!isNaN(args) && args.length > 0)
 
 
  if    (!(message.guild.roles.find("name",`${args}`))) return  message.channel.sendEmbed(embedd);
 
 
  var a = message.guild.roles.find("name",`${args}`)
   if(!a)return;
  const embed = new Discord.RichEmbed()
 
  .setFooter('Requested by '+message.author.username, message.author.avatarURL)
  .setDescription(`<a:x13:712913365508292610> **-** **Done Give You This Color**`)
 
  .setColor(`${a.hexColor}`)
  message.channel.sendEmbed(embed);
  if (!args)return;
  setInterval(function(){})
     let count = 0;
     let ecount = 0;
  for(let x = 1; x < 201; x++){
 
  message.member.removeRole(message.guild.roles.find("name",`${x}`))
 
  }
   message.member.addRole(message.guild.roles.find("name",`${args}`));
 
 
  }
  });
 


//ban
client.on("message", message => {
  if (message.content.split(" ")[0] == `$ban`) {
    if (!message.guild || message.author.bot) return undefined;
    if (!message.member.hasPermission("BAN_MEMBERS"))
      return message.channel.send("You don't have permission.");
    if (!message.guild.member(client.user).hasPermission("BAN_MEMBERS"))
      return message.channel.send("I don't have permission.");
    let args = message.content.split(" ").slice(1);
    let user =
      message.guild.members.get(message.content.split(" ")[1]) ||
      message.mentions.members.first();
    let reason = message.content
      .split(" ")
      .slice(2)
      .join(" ");
    if (!user)
      return message.channel.send(`Usage: ${prefix}ban @mention reason`);
    if (!reason) reason = "No reason provided.";
    if (user.user.id === message.author.id)
      return message.channel.send("You can't ban yourself!");
    if (
      message.guild.member(user.user).highestRole.position >=
      message.guild.member(client.user).highestRole.position
    )
      return message.channel.send(
        `I can't ban **${user.user.tag}** because his role highest than my role!`
      );
    if (!message.guild.member(user.user).bannable)
      return message.channel.send(`I can't ban **${user.user.tag}**.`);
    message.guild.member(user).ban(reason, user);
    message.channel.send(
      `Done :+1:, I Banned ${user.user.username} from the server!\nReason: \`\`${reason}\`\``
    );
  }
});



//////////unban
client.on("message", message => {
  let command = message.content.split(" ")[0];
  if (command == prefix + "unban") {
    if (!message.member.hasPermission("BAN_MEMBERS")) return;
    let args = message.content
      .split(" ")
      .slice(1)
      .join(" ");
    if (args == "all") {
      message.guild.fetchBans().then(zg => {
        zg.forEach(NoNo => {
          message.guild.unban(NoNo);
        });
      });
      return message.channel.send("**âœ… Unbanned all members **");
    }
    if (!args)
      return message.channel.send("**Please Type the member ID / all**");
    message.guild
      .unban(args)
      .then(m => {
        message.channel.send(`**âœ… Unbanned ${m.username}**`);
      })
      .catch(stry => {
        message.channel.send(
          `**ğŸ™„ - I can't find \`${args}\` in the ban list**`
        );
      });
  }
});








////kick


 





////leave
        client.on('message', message=>{  
    if(message.author.bot) return;  
    if(!message.channel.guild) return;
    if(message.content.startsWith(prefix+'setleave')) {  
    if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply("**ØªØ­ØªØ§Ø¬ Ø§Ù„Ù‰ `MANAGE_CHANNELS`**");
    let leave = message.guild.channels.find("name", "âœ‹leaveâœ‹")  
    if(leave) return message.reply("**ÙŠÙˆØ¬Ø¯  Ø±ÙˆÙ… Ø¨Ø§Ù„ÙØ¹Ù„**")   
    if(!leave) {   
    message.guild.createChannel("âœ‹leaveâœ‹", "text").then(c=> {  
        c.overwritePermissions(message.guild.id, {  
            SEND_MESSAGES: false
    })
})
message.channel.send("**âœ… ,ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø±ÙˆÙ… Ø§Ù„Ù…ØºØ§Ø¯Ø±ÙŠÙ†**")
    }
    }  
     })



//brodacst
client.on('message', message => {
  if(!message.channel.guild) return;
if(message.content.startsWith('$bc')) {
if(!message.channel.guild) return message.channel.send('**Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª**').then(m => m.delete(5000));
if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù„Ù„Ø£Ø³Ù Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ©** `ADMINISTRATOR`' );
let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
let copy = "ScrpitBot";
let request = `Requested By ${message.author.username}`;
if (!args) return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© Ø§Ùˆ Ø¬Ù…Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª**');message.channel.send(`**Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø±Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³ØªØŸ \nÙ…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª:** \` ${args}\``).then(msg => {
msg.react('âœ…')
.then(() => msg.react('âŒ'))
.then(() =>msg.react('âœ…'))

let reaction1Filter = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === message.author.id;
let reaction2Filter = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;
let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
reaction1.on("collect", r => {
message.channel.send(`â˜‘ | Done ... The Broadcast Message Has Been Sent For ${message.guild.members.size} Members`).then(m => m.delete(5000));
message.guild.members.forEach(m => {
var bc = new
Discord.RichEmbed()
.setColor('RANDOM')
.setTitle('Broadcast')
.addField('Server', message.guild.name)
.addField('Sender', message.author.username)
.addField('Message', args)
.setThumbnail(message.author.avatarURL)
.setFooter(copy, client.user.avatarURL);
m.send({ embed: bc })
msg.delete();
})
})
reaction2.on("collect", r => {
message.channel.send(`**Broadcast Canceled.**`).then(m => m.delete(5000));
msg.delete();
})
})
}
});
client.on('message', message => {
   if(!message.channel.guild) return;
if(message.content.startsWith(prefix + 'bk')) {
if(!message.channel.guild) return message.channel.send('**Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª**').then(m => m.delete(5000));
if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù„Ù„Ø£Ø³Ù Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ©** `ADMINISTRATOR`' );
let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
let BcList = new Discord.RichEmbed()
.setThumbnail(message.author.avatarURL)
.setAuthor(`Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ ${args}`)
.setDescription(`Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø¨Ù€ Ø§Ù…Ø¨Ø¯ ğŸ“\nØ¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø¨Ø¯ÙˆÙ† Ø§Ù…Ø¨Ø¯âœ \nÙ„Ø¯ÙŠÙƒ Ø¯Ù‚ÙŠÙ‚Ù‡ Ù„Ù„Ø£Ø®ØªÙŠØ§Ø± Ù‚Ø¨Ù„ Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª`)
if (!args) return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© Ø§Ùˆ Ø¬Ù…Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª**');message.channel.send(BcList).then(msg => {
msg.react('ğŸ“')
.then(() => msg.react('âœ'))
.then(() =>msg.react('ğŸ“'))
 
let EmbedBcFilter = (reaction, user) => reaction.emoji.name === 'ğŸ“' && user.id === message.author.id;
let NormalBcFilter = (reaction, user) => reaction.emoji.name === 'âœ' && user.id === message.author.id;
 
let EmbedBc = msg.createReactionCollector(EmbedBcFilter, { time: 60000 });
let NormalBc = msg.createReactionCollector(NormalBcFilter, { time: 60000 });
 
EmbedBc.on("collect", r => {
message.channel.send(`:ballot_box_with_check: ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø¨Ù†Ø¬Ø§Ø­`).then(m => m.delete(5000));
message.guild.members.forEach(m => {
var bc = new
Discord.RichEmbed()
.setColor('RANDOM')
.setDescription(`Message : ${args}`)
.setAuthor(`Server : ${message.guild.name}`)
.setFooter(`Sender : ${message.author.username}`)
.setThumbnail(message.author.avatarURL)
m.send({ embed: bc })
msg.delete();
})
})
NormalBc.on("collect", r => {
  message.channel.send(`:ballot_box_with_check: ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø¨Ù†Ø¬Ø§Ø­`).then(m => m.delete(5000));
message.guild.members.forEach(m => {
m.send(args);
msg.delete();
})
})
})
}
});
client.on('message' , message => {
      if(message.author.bot) return;
     
      if(message.content.startsWith(prefix + "rbc")) {
        if (!message.member.hasPermission("ADMINISTRATOR"))  return;
        let args = message.content.split(" ").slice(2);
     var codes = args.join(' ')
       
        if(!codes) {
          message.channel.send("Ù‚Ù… Ø¨ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© | !rbc @everyone message")
            return;
        }
     
     
              var role = message.mentions.roles.first();
                if(!role) {
                  message.reply("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±ØªØ¨Ø© Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³Ù…")
                    return;
                }
            message.guild.members.filter(m => m.roles.get(role.id)).forEach(n => {
              n.send(
              "**" + "Ø§Ù„Ø³ÙŠØ±ÙØ± :" + "\n" +
              `${message.guild.name}` + "\n" +
              "Ø§Ù„Ù…Ø±Ø³Ù„ :" + "\n" +
              `${message.author.tag}` + "\n" +
              "Ø§Ù„Ø±Ø³Ø§Ù„Ø© :" + "\n" +
              `${codes}` + "**"
              )
            })
            message.channel.send(`Ù„Ù‚Ø¯ ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù‰ ${message.guild.members.filter(m => m.roles.get(role.id)).size} Ø¹Ø¶Ùˆ`)
        }
    });


//avatarserver
client.on("message", message => {
    const prefix = "$"
              
          if(!message.channel.guild) return;
   if(message.author.bot) return;
      if(message.content === prefix + "savatar"){
          const embed = new Discord.RichEmbed()
  
      .setTitle(`ServerAvatar${message.guild.name}  `)
  .setAuthor(message.author.username, message.guild.iconrURL)
    .setColor(0x164fe3)
    .setImage(message.guild.iconURL)
    .setURL(message.guild.iconrURL)
                    .setTimestamp()

   message.channel.send({embed});
      }
  });



















/////ÙƒÙˆØ¯ Ø§Ù†ÙØ§ÙŠØª




client.on("guildMemberAdd", member => {
  member.createDM().then(function (channel) {
  return channel.send(`
:rose:  **ÙˆÙ„ÙƒÙ… Ù†ÙˆØ±Øª Ø§Ù„Ø³ÙŠØ±ÙØ±**:rose: 
:zap:**Ø§Ù†Øª Ø§Ù„Ø¹Ø¶Ùˆ Ø±Ù‚Ù…** ${member.guild.memberCount} :zap:
:crown:**${member}**:crown:`) 
}).catch(console.error)
})



//cr Ù„ØµÙ†Ø¹ Ø±ØªØ¨ Ø§Ù„ÙˆØ§Ù†
client.on('message', msg => {
                        let args = msg.content.split(" ").slice(1).join(" ")
if (msg.content.split(" ")[0].toLowerCase() === "$cr") {
    if(!args) return msg.channel.send('`Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù„ÙˆØ§Ù† Ø§Ù„Ù…Ø±Ø¬Ù‰ ØµÙ†Ø¹Ù‡Ø§`');
             if (!msg.member.hasPermission('MANAGE_ROLES')) return;
              msg.channel.send(`** Done Colors Was Successful Created ${args}**`);
                  setInterval(function(){})
                    let count = 0;
                    let ecount = 0;
          for(let x = 1; x < `${parseInt(args)+1}`; x++){
            msg.guild.createRole({name:x,
              color: 'RANDOM'})
              }
            }
});



//Ù‚ÙÙ„ ÙˆÙØªØ­ Ø§Ù„Ø´Ø§Øª
client.on("message", message => {
  if (message.content === prefix + "close") {
    if (!message.channel.guild)
      return message.reply(" Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!");

    if (!message.member.hasPermission("MANAGE_MESSAGES"))
      return message.reply(" Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª");
    message.channel
      .overwritePermissions(message.guild.id, {
        SEND_MESSAGES: false
      })
      .then(() => {
        message.reply("**ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ø´Ø§Øª :no_entry: **");
      });
  }
  if (message.content === prefix + "open") {
    if (!message.channel.guild)
      return message.reply(" Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!");

    if (!message.member.hasPermission("MANAGE_MESSAGES"))
      return message.reply("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª");
    message.channel
      .overwritePermissions(message.guild.id, {
        SEND_MESSAGES: true
      })
      .then(() => {
        message.reply("**ØªÙ… ÙØªØ­ Ø§Ù„Ø´Ø§Øª :white_check_mark:**");
      });
  }
});



client.on("message", message => {
  if (message.content === prefix + "Ù‚ÙÙ„") {
    if (!message.channel.guild)
      return message.reply(" Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!");

    if (!message.member.hasPermission("MANAGE_MESSAGES"))
      return message.reply(" Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª");
    message.channel
      .overwritePermissions(message.guild.id, {
        SEND_MESSAGES: false
      })
      .then(() => {
        message.reply("**:lock: has been locked.**");
      });
  }
  if (message.content === prefix + "ÙØªØ­") {
    if (!message.channel.guild)
      return message.reply(" Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!");

    if (!message.member.hasPermission("MANAGE_MESSAGES"))
      return message.reply("Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª");
    message.channel
      .overwritePermissions(message.guild.id, {
        SEND_MESSAGES: true
      })
      .then(() => {
        message.reply("**:unlock: has been unlocked.**");
      });
  }
});



//send
const perfix = '$';
client.on('message', msg => {
   if (msg.content.startsWith(prefix + 'send')) {
      let args = msg.content.split(' ').slice(1)
      if (!args[0]) return msg.reply(`**Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø§ÙˆÙ„Ø§**`)
      if (!args[1]) return msg.reply(`**Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø§Ø±Ø³Ø§Ù„Ù‡Ø§**`)
      let alpha = msg.mentions.members.first()
      if (!alpha) return msg.reply(`**ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´Ø®Øµ**`)
      let alphaEmbed = new Discord.RichEmbed()
      .setDescription(args.join(" "))

      client.users.get(`${alpha.id}`).send(alphaEmbed)
      msg.reply(`**ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡**`)
    }
});














//Ø§ÙƒÙˆØ§Ø¯ Ø­Ù…Ø§ÙŠØ©
let anti = JSON.parse(fs.readFileSync("./antigreff.json", "UTF8"));
let config = JSON.parse(fs.readFileSync("./server.json", "UTF8"));
client.on("message", message => {
    if (!message.channel.guild) return;
    let user = anti[message.guild.id + message.author.id]
    let num = message.content.split(" ").slice(2).join(" ");
    if (!anti[message.guild.id + message.author.id]) anti[message.guild.id + message.author.id] = {
        actions: 0
    }
    if (!config[message.guild.id]) config[message.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3,
        time: 30
    }
    if (message.content.startsWith(prefix + "settings limits")) {
 
 
        if (message.author.id !== message.guild.owner.user.id) return message.channel.send(`**Ù„Ø§ ØªØ³ØªØ·ÙŠØ¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø±**`);
        if (message.content.startsWith(prefix + "settings limitsban")) {
            if (!num) return message.channel.send("**â‡ | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
            if (isNaN(num)) return message.channel.send("**â‡ | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
            config[message.guild.id].banLimit = num;
            message.channel.send(`**â‡ | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].banLimit} **`)
        }
        if (message.content.startsWith(prefix + "settings limitskick")) { 
            if (!num) return message.channel.send("**â‡ | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
            if (isNaN(num)) return message.channel.send("**â‡ | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
            config[message.guild.id].kickLimits = num;
            message.channel.send(`**â‡ | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].kickLimits}**`)
        }
        if (message.content.startsWith(prefix + "settings limitsroleD")) {
            if (!num) return message.channel.send("**â‡ | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
            if (isNaN(num)) return message.channel.send("**â‡ | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
            config[message.guild.id].roleDelLimit = num;
            message.channel.send(`**â‡ | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].roleDelLimit}**`)
        }
        if (message.content.startsWith(prefix + "settings limitsroleC")) {
            if (!num) return message.channel.send("**â‡ | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
            if (isNaN(num)) return message.channel.send("**â‡ | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
            config[message.guild.id].roleCrLimits = num;
            message.channel.send(`**â‡ | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].roleCrLimits}**`)
        }
        if (message.content.startsWith(prefix + "settings limitschannelD")) {
            if (!num) return message.channel.send("**â‡ | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
            if (isNaN(num)) return message.channel.send("**â‡ | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
            config[message.guild.id].chaDelLimit = num;
            message.channel.send(`**â‡ | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].chaDelLimit}**`)
        }
        if (message.content.startsWith(prefix + "settings limitstime")) {
            if (!num) return message.channel.send("**â‡ | Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… ! **");
            if (isNaN(num)) return message.channel.send("**â‡ | Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø· ! **");
            config[message.guild.id].time = num;
            message.channel.send(`**â‡ | ØªÙ… Ø§Ù„ØªØºÙŠÙŠØ± Ø§ÙÙ„ÙŠ : ${config[message.guild.id].time}**`)
        }
        fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
            if (e) throw e;
        });
        fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
            if (e) throw e;
        });
    }
});
client.on("channelDelete", async channel => {
    const entry1 = await channel.guild.fetchAuditLogs({
        type: 'CHANNEL_DELETE'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[channel.guild.id]) config[channel.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    } 
    if (!anti[channel.guild.id + entry.id]) {
        anti[channel.guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
    } else {
        anti[channel.guild.id + entry.id].actions = Math.floor(anti[channel.guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
        if (anti[channel.guild.id + entry.id].actions >= config[channel.guild.id].chaDelLimit) {
            channel.guild.members.get(entry.id).ban().catch(e => channel.guild.owner.send(`**â‡ | ${entry.username} Ù‚Ø§Ù… Ø¨Ù…Ø³Ø­ Ø§Ù„ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„Ø±ÙˆÙ…Ø§Øª **`))
            anti[channel.guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("roleDelete", async channel => {
    const entry1 = await channel.guild.fetchAuditLogs({
        type: 'ROLE_DELETE'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[channel.guild.id]) config[channel.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[channel.guild.id + entry.id]) {
        anti[channel.guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
    } else {
        anti[channel.guild.id + entry.id].actions = Math.floor(anti[channel.guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
        if (anti[channel.guild.id + entry.id].actions >= config[channel.guild.id].roleDelLimit) {
            channel.guild.members.get(entry.id).ban().catch(e => channel.guild.owner.send(`**â‡ | ${entry.username} Ù‚Ø§Ù… Ø¨Ù…Ø³Ø­ Ø§Ù„ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„Ø±ØªØ¨ **`))
            anti[channel.guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("roleCreate", async channel => {
    const entry1 = await channel.guild.fetchAuditLogs({
        type: 'ROLE_CREATE'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[channel.guild.id]) config[channel.guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[channel.guild.id + entry.id]) {
        anti[channel.guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
    } else {
        anti[channel.guild.id + entry.id].actions = Math.floor(anti[channel.guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[channel.guild.id + entry.id].actions = "0"
        }, config[channel.guild.id].time * 1000)
        if (anti[channel.guild.id + entry.id].actions >= config[channel.guild.id].roleCrLimits) {
            channel.guild.members.get(entry.id).ban().catch(e => channel.guild.owner.send(`**â‡ | ${entry.username} Ù‚Ø§Ù… Ø¨Ø£Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„Ø±ØªØ¨ **`))
            anti[channel.guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("guildBanAdd", async (guild, user) => {
    const entry1 = await guild.fetchAuditLogs({
        type: 'MEMBER_BAN_ADD'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[guild.id]) config[guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[guild.id + entry.id]) {
        anti[guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
    } else {
        anti[guild.id + entry.id].actions = Math.floor(anti[guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
        if (anti[guild.id + entry.id].actions >= config[guild.id].banLimit) {
            guild.members.get(entry.id).ban().catch(e => guild.owner.send(`**â‡ | ${entry.username} Ø­Ø§ÙˆÙ„ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ **`))
            anti[guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("guildKickAdd", async (guild, user) => {
    const entry1 = await guild.fetchAuditLogs({
        type: 'MEMBER_KICK'
    }).then(audit => audit.entries.first())
    console.log(entry1.executor.username)
    const entry = entry1.executor
    if (!config[guild.id]) config[guild.id] = {
        banLimit: 3,
        chaDelLimit: 3,
        roleDelLimit: 3,
        kickLimits: 3,
        roleCrLimits: 3
    }
    if (!anti[guild.id + entry.id]) {
        anti[guild.id + entry.id] = {
            actions: 1
        }
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
    } else {
        anti[guild.id + entry.id].actions = Math.floor(anti[guild.id + entry.id].actions + 1)
        console.log("TETS");
        setTimeout(() => {
            anti[guild.id + entry.id].actions = "0"
        }, config[guild.id].time * 1000)
        if (anti[guild.id + entry.id].actions >= config[guild.id].banLimit) {
            guild.members.get(entry.id).ban().catch(e => guild.owner.send(`**â‡ | ${entry.username} Ø­Ø§ÙˆÙ„ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ **`))
            anti[guild.id + entry.id].actions = "0"
            fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                if (e) throw e;
            });
            fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                if (e) throw e;
            });
        }
    }
 
    fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
        if (e) throw e;
    });
    fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
        if (e) throw e;
    });
});
 
client.on("guildMemberRemove", async member => {
    const entry1 = await member.guild.fetchAuditLogs().then(audit => audit.entries.first())
    if (entry1.action === "MEMBER_KICK") {
        const entry2 = await member.guild.fetchAuditLogs({
            type: "MEMBER_KICK"
        }).then(audit => audit.entries.first())
        const entry = entry2.executor;
        if (!config[member.guild.id]) config[guild.id] = {
            banLimit: 3,
            chaDelLimit: 3,
            roleDelLimit: 3,
            kickLimits: 3,
            roleCrLimits: 3
        }
        if (!anti[member.guild.id + entry.id]) {
            anti[member.guild.id + entry.id] = {
                actions: 1
            }
            setTimeout(() => {
                anti[member.guild.id + entry.id].actions = "0"
            }, config[member.guild.id].time * 1000)
        } else {
            anti[member.guild.id + entry.id].actions = Math.floor(anti[member.guild.id + entry.id].actions + 1)
            console.log("TETS");
            setTimeout(() => {
                anti[member.guild.id + entry.id].actions = "0"
            }, config[member.guild.id].time * 1000)
            if (anti[member.guild.id + entry.id].actions >= config[member.guild.id].kickLimits) {
                member.members.get(entry.id).ban().catch(e => member.owner.send(`**â‡ | ${entry.username} Ø­Ø§ÙˆÙ„ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡ **`))
                anti[member.guild.id + entry.id].actions = "0"
                fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
                    if (e) throw e;
                });
                fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
                    if (e) throw e;
                });
            }
        }
 
        fs.writeFile("./config.json", JSON.stringify(config, null, 2), function (e) {
            if (e) throw e;
        });
        fs.writeFile("./antigreff.json", JSON.stringify(anti, null, 2), function (e) {
            if (e) throw e;
        });
    }
 
})

client.antibots = new Enmap({ name: "chat" });
var antibots = client.antibots;
var julian = client;
julian.on("message", codes => {
  if (codes.content.startsWith(prefix + "antibots on")) {
    if (
      codes.author.bot ||
      !codes.channel.guild ||
      codes.author.id != codes.guild.ownerID
    )
      return;
    antibots.set(`${codes.guild.id}`, {
      onoff: "On"
    });

    codes.channel.send("** AntiBots Join Is On :lock: **");
  }
  if (codes.content.startsWith(prefix + "antibots off")) {
    if (
      codes.author.bot ||
      !codes.channel.guild ||
      codes.author.id != codes.guild.ownerID
    )
      return;
    antibots.set(`${codes.guild.id}`, {
      onoff: "Off"
    });
    codes.channel.send("** AntiBots Join Is Off :unlock: **");
  }
});

julian.on("guildMemberAdd", member => {
  if (!antibots.get(`${member.guild.id}`)) {
    antibots.set(`${member.guild.id}`, {
      onoff: "Off"
    });
  }
  if (antibots.get(`${member.guild.id}`).onoff == "Off") return;
  if (member.user.bot) return member.kick();
});





//xo
client.on('message' , message => {
  if(message.author.bot) return;
  if(message.content.startsWith(prefix + "xo")) {
 let array_of_mentions = message.mentions.users.array();
  let symbols = [':o:', ':heavy_multiplication_x:']
  var grid_message;
 
  if (array_of_mentions.length == 1 || array_of_mentions.length == 2) {
    let random1 = Math.floor(Math.random() * (1 - 0 + 1)) + 0;
    let random2 = Math.abs(random1 - 1);
    if (array_of_mentions.length == 1) {
      random1 = 0;
      random2 = 0;
    }
    var player1_id = message.author.id
    let player2_id = array_of_mentions[random2].id;
    var turn_id = player1_id;
    var symbol = symbols[0];
    let initial_message = `Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨ÙŠÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„ØªØ§Ù„ÙŠÙŠÙ† <@${player1_id}> and <@${player2_id}>!`;
    if (player1_id == player2_id) {
      initial_message += '\n_(Ù„Ù‚Ø¯ Ø®Ø³Ø±Øª, Ø§Ù„Ø¹Ø¨ Ù…Ø¹ Ù†ÙØ³Ùƒ :joy:)_'
    }
    message.channel.send(`Xo ${initial_message}`)
    .then(console.log("Successful tictactoe introduction"))
    .catch(console.error);
    message.channel.send(':one::two::three:' + '\n' +
                         ':four::five::six:' + '\n' +
                         ':seven::eight::nine:')
    .then((new_message) => {
      grid_message = new_message;
    })
    .then(console.log("Successful tictactoe game initialization"))
    .catch(console.error);
    message.channel.send('Loading... Please wait for the :ok: reaction.')
    .then(async (new_message) => {
      await new_message.react('1âƒ£');
      await new_message.react('2âƒ£');
      await new_message.react('3âƒ£');
      await new_message.react('4âƒ£');
      await new_message.react('5âƒ£');
      await new_message.react('6âƒ£');
      await new_message.react('7âƒ£');
      await new_message.react('8âƒ£');
      await new_message.react('9âƒ£');
      await new_message.react('ğŸ†—');
      await new_message.edit(`It\'s <@${turn_id}>\'s Ø§Ø´ØªØºÙ„! Ø§Ù„Ø±Ù…Ø² Ù‡Ùˆ ${symbol}`)
      .then((new_new_message) => {
        require('./xo.js')(client, message, new_new_message, player1_id, player2_id, turn_id, symbol, symbols, grid_message);
      })
      .then(console.log("Successful tictactoe listeprefix initialization"))
      .catch(console.error);
    })
    .then(console.log("Successful tictactoe react initialization"))
    .catch(console.error);
  }
  else {
    message.channel.send(`Ø¬Ø±Ø¨ $xo @uesr`)
    .then(console.log("Successful error reply"))
    .catch(console.error);
  }
}
 });




//say
client.on("message", message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "say") {
    if (!message.member.hasPermission("ADMINISTRATOR"))
      return message.channel.send(
        "**ADMINISTRATOR Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª :rolling_eyes:**"
      );

    message.channel.send("" + args.join("  "));
    message.delete();
  }
});



//talk
client.on('message',message =>   {
  if(message.channel.type == 'dm') return;
  if(message.content.startsWith(prefix + "talk")) {
      var attentions = {};
      attentions[message.guild.id] = { };
      message.channel.send( message.author + ', **Wait , PuP System**').then( (m) =>{
      m.edit( message.author + ', **Ø£Ø±Ø³Ù„ Ø£ÙŠØ¯ÙŠ Ø§Ù„Ø±ÙˆÙ…**' )
      m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 600000 } ).then ( (m1) => {
      m1 = m1.first();
      attentions[message.guild.id]['id'] = m1.content;
      m1.delete();
m1 = message.guild.channels.get(`${attentions[message.guild.id]['id']}`)
if(!m1) return message.reply(`**Ø§Ù„Ø£ÙŠØ¯ÙŠ Ù‡Ø°Ø§ ØºÙŠØ± ØµØ­ÙŠØ­ \`${attentions[message.guild.id]['id']}\`**`);
 
      m.edit(message.author+"**,  ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø±Ø³Ø§Ù„Ø© Ù…Ø¹ÙŠÙ†Ø© **")
      m.channel.awaitMessages( m2 => m2.author == message.author,{ maxMatches: 1, time: 600000 }).then ( (m2) => {
      m2 = m2.first();
      attentions[message.guild.id]['msg'] = m2.content;
      m2.delete();
      m.delete();
      message.channel.send(`**Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„ ÙÙŠ Ø±ÙˆÙ… <#${attentions[message.guild.id]['id']}>
${attentions[message.guild.id]['msg']}**`).then(msge => {
      msge.react('âœ…').then( r => {
      msge.react('âŒ')
      const oneFilterBB = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === message.author.id;
      const threeFilterBB = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;
      const oneBY = msge.createReactionCollector(oneFilterBB, {maxMatches : 1,time : 400000,});
      const threeBY = msge.createReactionCollector(threeFilterBB, {maxMatches : 1,time : 400000,});
      oneBY.on('collect', r => {
      msge.delete();
      message.guild.channels.get(`${attentions[message.guild.id]['id']}`).send(`${attentions[message.guild.id]['msg']}`)
      }).catch(RebeL =>{ console.log('`Error`: ' + RebeL)});
          threeBY.on('collect', r => {
      msge.delete();
      })
      })
  })
      });
      });
      });
     
    }
    });














////ØªÙ‚Ø¯ÙŠÙ…

client.on("message", message => {
  if (message.content == prefix + "submit") {
    if (!message.channel.guild) return;
    if (message.author.bot) return;
    let channel = message.guild.channels.find("name", "ØªÙ€Ù‚Ù€Ø¯ÙŠÙ€Ù…");
    if (!channel)
      return message.reply(
        "<a:x30:714394016883540031> | **Type [ -room 1 ] To Make Room Submit.**"
      );
    if (channel) {
      message.channel.send(message.member + ", **:timer:**").then(m => {
        m.edit(message.member + ", **Ø§Ø³Ù€Ù…Ù€Ù€Ùƒ  âœ**");
        m.channel
          .awaitMessages(m1 => m1.author == message.author, {
            maxMatches: 1,
            time: 60 * 1000
          })
          .then(m1 => {
            m1 = m1.first();
            var name = m1.content;
            m1.delete();
            m.edit(message.member + ", **:timer:**").then(m => {
              m.edit(message.member + ", **Ø¹Ù€Ù€Ù…Ù€Ù€Ø±Ùƒ ğŸ“**");
              setTimeout(() => {
                m.delete();
              }, 10000);
              m.channel
                .awaitMessages(m2 => m2.author == message.author, {
                  maxMatches: 1,
                  time: 60 * 1000
                })
                .then(m2 => {
                  m2 = m2.first();
                  var age = m2.content;
                  m2.delete();
                  message.channel
                    .send(message.member + ", **:timer:**")
                    .then(m => {
                      m.edit(message.member + ", **ØªÙ€Ø³Ù€Ø§Ø¹Ù€Ø¯Ù†Ù€Ø§ Ø¨Ø£ÙŠÙ€Ù€Ø© ğŸ™**");
                      setTimeout(() => {
                        m.delete();
                      }, 10000);
                      m.channel
                        .awaitMessages(m1 => m1.author == message.author, {
                          maxMatches: 1,
                          time: 60 * 1000
                        })
                        .then(m3 => {
                          m3 = m3.first();
                          var ask = m3.content;
                          m3.delete();
                          message.channel
                            .send(message.member + ", **:timer:**")
                            .then(m => {
                              m.edit(
                                message.member + ", **Ù‡Ù€ØªÙ€Ø­Ù€ØªÙ€Ø±Ù… Ø§Ù„Ù€Ù‚Ù€ÙˆØ§Ù†Ù€ÙŠÙ€Ù† ğŸ“‘**"
                              );
                              setTimeout(() => {
                                m.delete();
                              }, 10000);
                              m.channel
                                .awaitMessages(
                                  m1 => m1.author == message.author,
                                  { maxMatches: 1, time: 60 * 1000 }
                                )
                                .then(m4 => {
                                  m4 = m4.first();
                                  var ask2 = m4.content;
                                  m4.delete();
                                  message.channel
                                    .send(message.member + ", **:timer:**")
                                    .then(m => {
                                      m.edit(
                                        message.member +
                                          ", **Ø£Ù‚Ø³Ù€Ù… Ø§Ù†Ù€ÙŠ Ù…Ù€Ø§ Ø£Ø¨Ù€ÙˆØ¸ Ø³Ù€Ù…Ù€Ø¹Ù€Ø© Ø§Ù„Ù€Ø³Ù€ÙŠÙ€Ø±ÙÙ€Ø± Ø£Ø¨Ù€Ø¯Ø§ ğŸ¤”**"
                                      );
                                      m.channel
                                        .awaitMessages(
                                          m1 => m1.author == message.author,
                                          { maxMatches: 1, time: 60 * 1000 }
                                        )
                                        .then(m5 => {
                                          m5 = m5.first();
                                          var ask3 = m5.content;
                                          m5.delete();
                                          m.edit(
                                            message.member +
                                              ", **... Ø¬Ù€Ø§Ø±ÙŠ Ø¬Ù€Ù…Ù€Ø¹ Ø§Ù„Ù€Ø¨Ù€ÙŠÙ€Ø§Ù†Ù€Ø§Øª**"
                                          ).then(mtime => {
                                            setTimeout(() => {
                                              let embed = new Discord.RichEmbed()
                                                .setColor("RANDOM")
                                                .setTitle(
                                                  `**New Submit.** [__**${message.guild.name}**__]`
                                                )
                                                .addField(
                                                  "**`Ø§Ù„Ø§Ø³Ù…`**",
                                                  `${name}`,
                                                  true
                                                )
                                                .addField(
                                                  "**`Ø§Ù„Ø¹Ù…Ø±`**",
                                                  `${age}`,
                                                  true
                                                )
                                                .addField(
                                                  "**`Ø§Ù„Ù€Ù…Ù€Ø³Ù€Ø§Ø¹Ù€Ø¯Ø©`**",
                                                  `${ask}`
                                                )
                                                .addField(
                                                  "**`Ø§Ø­Ù€ØªÙ€Ø±Ø§Ù… Ø§Ù„Ù€Ù‚Ù€ÙˆØ§Ù†Ù€ÙŠÙ€Ù†`**",
                                                  `${ask2}`
                                                )
                                                .addField(
                                                  "**`Ø§Ù„Ù€Ù‚Ù€Ø³Ù€Ù…`**",
                                                  `${ask3}`
                                                )
                                                .setFooter(
                                                  message.author.username,
                                                  "https://images-ext-2.discordapp.net/external/JpyzxW2wMRG2874gSTdNTpC_q9AHl8x8V4SMmtRtlVk/https/orcid.org/sites/default/files/files/ID_symbol_B-W_128x128.gif"
                                                );
                                              channel.send(embed);
                                            }, 2500);
                                            setTimeout(() => {
                                              mtime.delete();
                                            }, 3000);
                                          });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
          });
      });
    }
  }
});

client.on("message", message => {
  if (message.content == prefix + "room 1") {
    if (!message.channel.guild) return;
    if (message.author.bot) return;
    if (!message.member.hasPermission("ADMINISTRATOR"))
      return message.reply("<a:x30:714394016883540031> | **You Don't Have Permission.**");
    message.guild.createChannel("ØªÙ€Ù‚Ù€Ø¯ÙŠÙ€Ù…", "text").then(c => {
      c.overwritePermissions(message.guild.id, {
        SEND_MESSAGES: false
      });
    });
    message.channel.send("<a:x13:712913365508292610> | **ØªÙ€Ù… Ø§Ù†Ù€Ø´Ù€Ø§Ø¡ Ø±ÙˆÙ… ØªÙ€Ù‚Ù€Ø¯ÙŠÙ€Ù…**");
  }
});
client.on("message", async message => {
  let mention = message.mentions.members.first();
  let role = message.content
    .split(" ")
    .slice(2)
    .join(" ");
  let mySupport = message.guild.roles.find("name", role);
  if (message.content == prefix + "apply") {
    let acRoom = message.guild.channels.find("name", "Ù‚Ù€Ø¨Ù€ÙˆÙ„-Ø±ÙÙ€Ø¶");
    if (!acRoom)
      return message.reply(
        "<a:x30:714394016883540031> | **Type [ -room 2 ] To Make Room Reject or Apply.**"
      );
    if (acRoom) {
      if (!message.guild.member(message.author).hasPermission("MANAGE_ROLES"))
        return;
      if (!mention) return message.reply("<a:x30:714394016883540031> | Ù…Ù€Ù†Ù€Ø´Ù€Ù† Ø§Ù„Ù€Ø¹Ù€Ø¶Ù€Ùˆ");
      if (!role) return message.reply("<a:x30:714394016883540031> | Ø£Ø¯Ø®Ù€Ù„ Ø§Ø³Ù€Ù… Ø±ØªÙ€Ø¨Ù€Ø©");
      if (!mySupport) return message.reply("<a:x30:714394016883540031> | Ù„Ù€Ù… Ø£Ø¬Ù€Ø¯ Ù‡Ø°Ø© Ø§Ù„Ù€Ø±ØªÙ€Ø¨Ù€Ø©");
      if (mention.roles.has(mySupport))
        return message.reply("<a:x13:712913365508292610> | **Ù‡Ù€Ø°Ø§ Ø§Ù„Ù€Ø´Ù€Ø®Ù€Øµ ÙŠÙ€Ù…Ù€Ù„Ù€Ùƒ Ø§Ù„Ù€Ø±ØªÙ€Ø¨Ù€Ø©**");

      mention.addRole(mySupport).then(() => {
        acRoom.send(
          `**[ ${mySupport} ] ÙˆØ§Ø¹Ø·Ù€Ø§Ø¡Ùƒ Ø±ØªÙ€Ø¨Ù€Ø© ${mention} ØªÙ€Ù… Ù‚Ù€Ø¨Ù€ÙˆÙ„Ù€Ùƒ  <a:x13:712913365508292610>**`
        );
      });
    }
  }
});

client.on("message", async message => {
  let mention = message.mentions.members.first();
  if (message.content == prefix + "reject") {
    if (!message.channel.guild) return;
    let acRoom = message.guild.channels.find("name", "Ù‚Ù€Ø¨Ù€ÙˆÙ„-Ø±ÙÙ€Ø¶");
    if (!acRoom) return message.reply("<a:x30:714394016883540031> | **Type [ -room 1 ] To Make Room Submit.**");
    if (!message.guild.member(message.author).hasPermission("MANAGE_ROLES"))
      return;
    if (!mention) return message.reply("<a:x30:714394016883540031> | Ù…Ù€Ù†Ù€Ø´Ù€Ù† Ø§Ù„Ù€Ø¹Ù€Ø¶Ù€Ùˆ");

    acRoom.send(`<a:x13:712913365508292610> | **${mention} ØªÙ€Ù… Ø±ÙÙ€Ø¶Ù€Ùƒ Ù„Ù„Ø£Ø³Ù€Ù**`);
  }
});
client.on("message", message => {
  if (message.content == prefix + "room2") {
    if (!message.channel.guild) return;
    if (message.author.bot) return;
    if (!message.member.hasPermission("ADMINISTRATOR"))
      return message.reply("<a:x30:714394016883540031> | **You Don't Have Permission.**");
    message.guild.createChannel("Ù‚Ù€Ø¨Ù€ÙˆÙ„-Ø±ÙÙ€Ø¶", "text").then(c => {
      c.overwritePermissions(message.guild.id, {
        SEND_MESSAGES: false
      });
    });
    message.channel.send("<a:x13:712913365508292610> | **ØªÙ€Ù… Ø§Ù†Ù€Ø´Ù€Ø§Ø¡ Ø±ÙˆÙ… Ø§Ù„Ù€Ù‚Ù€Ø¨Ù€ÙˆÙ„-Ø§Ù„Ù€Ø±ÙÙ€Ø¶**");
  }
});


/////
///// [      1      ] ////
client.on('message', message => {
var cats = ["http://www.shuuf.com/shof/uploads/2015/09/09/jpg/shof_b9d73150f90a594.jpg","https://haltaalam.info/wp-content/uploads/2015/05/0.208.png","https://haltaalam.info/wp-content/uploads/2015/05/266.png","https://haltaalam.info/wp-content/uploads/2015/05/250.png","https://haltaalam.info/wp-content/uploads/2017/02/0.2517.png","https://pbs.twimg.com/media/CP0mi02UAAA3U2z.png","http://www.shuuf.com/shof/uploads/2015/08/31/jpg/shof_3b74fa7295ec445.jpg","http://www.shuuf.com/shof/uploads/2015/08/22/jpg/shof_fa3be6ab68fb415.jpg","https://pbs.twimg.com/media/CSWPvmRUcAAeZbt.png","https://pbs.twimg.com/media/B18VworIcAIMGsE.png"]
        var args = message.content.split(" ").slice(1);
    if(message.content.startsWith(prefix + 'hl')) {
         var cat = new Discord.RichEmbed()
.setImage(cats[Math.floor(Math.random() * cats.length)])
message.channel.sendEmbed(cat);
    }
});

//// [    2   ] ////
var spee={};
var fox="%";
let pointsfox= {}
const foxt = [
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055751447773195/bandicam_2019-07-16_14-38-25-841.jpg",
        "answers": ["Ø§Ù„Ø¨Ø±Ø§Ø²ÙŠÙ„"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055755080302593/bandicam_2019-07-17_17-14-28-589.jpg",
        "answers": ["Ø¨Ù„Ø¬ÙŠÙƒØ§"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055760180576276/bandicam_2019-07-17_17-15-04-686.jpg",
        "answers": ["ÙØ±Ù†Ø³Ø§"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055761467965452/bandicam_2019-07-17_17-15-42-926.jpg",
        "answers": ["ÙƒØ±ÙˆØ§ØªÙŠØ§"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055764542390287/bandicam_2019-07-17_17-16-28-291.jpg",
        "answers": ["Ø¨Ø±ØªØºØ§Ù„"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055766576889863/bandicam_2019-07-17_17-16-42-901.jpg",
        "answers": ["Ø³Ù†ØºØ§Ù„"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055769399525394/bandicam_2019-07-17_17-16-57-102.jpg",
        "answers": ["Ø³Ø¹ÙˆØ¯ÙŠØ©"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055772377350165/bandicam_2019-07-17_17-17-17-663.jpg",
        "answers": ["Ø§Ù„Ù…Ø§Ù†ÙŠØ§"]
    },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055773421862913/bandicam_2019-07-17_17-17-37-828.jpg",
        "answers": ["Ø§Ù„Ù…ÙƒØ³ÙŠÙƒ"]
          },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055773761732619/bandicam_2019-07-17_17-17-52-326.jpg",
        "answers": ["Ø§Ø±ØºÙˆØ§ÙŠ"]
          },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055830451683359/bandicam_2019-07-17_17-18-00-272.jpg",
        "answers": ["ØµØ±Ø¨ÙŠØ§"]
          },
    {
            "type": "https://cdn.discordapp.com/attachments/576512197275156502/601055832704155658/bandicam_2019-07-17_17-18-20-074.jpg",
        "answers": ["Ù…ØµØ±"]
       
    }
];
 






//ÙƒÙˆØ¯ ÙƒØ±ÙŠØ¯ÙŠØª
const cool = [];
client.on('message',async message => {
  if(message.author.bot) return;
  if(message.channel.type === 'dm') return;

  const args = message.content.split(' ');
  const Galers = require('./Galers.json');
  const path = './Galers.json';
  const mention = message.mentions.users.first() || client.users.get(args[1]) || message.author;
  const mentionn = message.mentions.users.first() || client.users.get(args[1]);
  const author = message.author.id;
  const balance = args[2];
  const daily = Math.floor(Math.random() * 350) + 10;

  if(!Galers[author]) Galers[author] = {Galers: 50};
  if(!Galers[mention.id]) Galers[mention.id] = {Galers: 50};
  fs.writeFile(path, JSON.stringify(Galers, null, 5), function(err) {if(err) console.log(err)});

  
  if(message.content.startsWith(prefix + "Galer")) {
  if(args[0] !== `${prefix}Galer` && args[0] !== `${prefix}Galers`) return;

  if(args[2]) {
	if(isNaN(args[2]) || args[2] < 0) return message.channel.send(' Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§Ù†Ø© ÙŠØ¬Ø¨ Ø§Ù† ØªØªÙƒÙˆÙ† Ù…Ù† Ø§Ø±Ù‚Ø§Ù… ØµØ­ÙŠØ­Ø© ÙˆÙ„ÙŠØ³ Ø§Ø­Ø±Ù.');
    if(mention.bot) return message.channel.send(`**:heavy_multiplication_x:| ${message.content.split(' ')[1]} Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰**`);
    if(mention.id === message.author.id) return message.channel.send('**:heavy_multiplication_x:| Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­ÙˆÙŠÙ„ ÙƒØ±Ø¯Øª Ù„Ù†ÙØ³Ùƒ**');
    if(Galers[author].Galers < balance) return message.channel.send('**:heavy_multiplication_x:| You Dont Have That Much Galer.**');
    var one = Math.floor(Math.random() * 9) + 1;
    var two = Math.floor(Math.random() * 9) + 1;
    var three = Math.floor(Math.random() * 9) + 1;
    var four = Math.floor(Math.random() * 9) + 1;

    var number = `${one}${two}${three}${four}`;
    
    message.channel.send(`**:heavy_dollar_sign:| \`${number}\`, Ø£ÙƒØªØ¨ Ø§Ù„Ø±Ù‚Ù… Ù„Ù„Ø£Ø³ØªÙ…Ø±Ø§Ø±**`).then(m => {
      message.channel.awaitMessages(m => m.author.id === message.author.id, {max: 1, time: 10000}).then(c => {
        if(c.first().content === number) {
          m.delete();
          message.channel.send(`**:atm:| ${message.author.username}, Ù‚Ø§Ù… Ø¨ØªØ­ÙˆÙŠÙ„ \`${balance}\` Ù„Ù€ ${mention}**`);
          Galers[author].Galers += (-balance);
          Galers[mention.id].Galers += (+balance);
          fs.writeFile(path, JSON.stringify(Galers, null, 5), function(err) {if(err) console.log(err)});
        } else if(c.first().content !== number) {
          m.delete();
          message.channel.send(`** :money_with_wings: | ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„**`);
        }
      });
    });
  }
  if(!args[2]) {
    if(mention.bot) return message.channel.send(`**:heavy_multiplication_x:| ${message.content.split(' ')[1]} Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰**`);
    message.channel.send(`**${mention.username}, your <a:Galercard:761320579532849181> balance is **${Galers[mention.id].Galers}`);
  } 
  
  }
  if(message.content.startsWith(prefix + "daily")) {
    if(cool.includes(message.author.id)) return message.channel.send(`**:heavy_dollar_sign: | \ , ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù†ØªØ¸Ø§Ø±  ÙŠÙˆÙ… Ù„Ø£Ø®Ø° Ø§Ù„Ù…Ø¨Ù„Øº Ù…Ø±Ø© Ø§Ø®Ø±Ù‰**`);
    if(mentionn) {
      var one = Math.floor(Math.random() * 9) + 1;
      var two = Math.floor(Math.random() * 9) + 1;
      var three = Math.floor(Math.random() * 9) + 1;
      var four = Math.floor(Math.random() * 9) + 1;
  
      var number = `${one}${two}${three}${four}`;

      message.channel.send(`**:atm: | \`${number}\`, Ù‚Ù… Ø¨ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ù‚Ù… Ù„Ù„Ø£Ø³ØªÙ…Ø±Ø§Ø±**`).then(async m => {
        message.channel.awaitMessages(msg => msg.author.id === message.author.id, {max: 1, time: 20000, errors: ['time']}).then(collected => {
          if(collected.first().content === number) {
            m.delete();
            collected.first().delete();
            Galers[mentionn.id].Galers += (+daily);
            fs.writeFile(path, JSON.stringify(Galers, null, 5), function(err) {if(err) console.log(err)});

          message.channel.send(`**:atm: | \`${daily}\`, ØªÙ… ØªØ³Ù„ÙŠÙ… Ø§Ù„Ù…Ø¨Ù„Øº**`);  
          }
          if(collected.first().content !== number) {
            return m.delete();
          }
        });
      });
    } else if(!mentionn) {
      Galers[author].Galers += (+daily);
      fs.writeFile(path, JSON.stringify(Galers, null, 5), function(err) {if(err) console.log(err)});

      message.channel.send(`**:atm: | \`${daily}\`, ØªÙ… Ø§Ø¹Ø·Ø§Ø¦Ùƒ Ø§Ù„Ù…Ø¨Ù„Øº**`);
    }
    cool.unshift(message.author.id);

    setTimeout(() => {
      cool.shift(message.author.id);
      message.author.send("**:atm: | \`Daily\`, ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ±Ø¯Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ© Ø§Ù„Ø§Ù†**").catch();
    }, ms("1d"));
  }
}); 
 








//inv
client.on("message", message => {
  if (message.author.bot) return;
  if (message.content === prefix + "inv") {
    message.channel.send(`                      
ØªÙØ¶Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨ÙˆØª <a:603943432469348362:762406606637105184>
<https://discord.com/api/oauth2/authorize?client_id=754368937738633217&permissions=8&scope=bot>
   `);
  }
});






